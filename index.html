<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ブロック崩しゲーム</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #111827; /* より濃い背景色 */
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }
        .game-wrapper {
            width: 100%;
            max-width: 500px;
            padding: 1rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .game-container {
            position: relative;
            width: 100%;
        }
        canvas {
            background: #1f2937;
            display: block;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 100%;
            aspect-ratio: 4 / 3;
        }
        .info-panel {
            color: white;
            margin-bottom: 1rem;
            font-size: 1.25rem;
            width: 100%;
            display: flex;
            justify-content: space-around;
        }
        .controls {
            color: #9ca3af;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        /* ★★★ 追加点: ゲーム開始/終了時のオーバーレイ ★★★ */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            border-radius: 0.5rem;
            text-align: center;
        }
    </style>
</head>
<body>

<div class="game-wrapper">
    <h1 class="text-3xl sm:text-4xl font-bold text-white mb-4">ブロック崩し</h1>
    <div id="info-panel" class="info-panel">
        <span>スコア: <span id="score">0</span></span>
        <span>ライフ: <span id="lives">3</span></span>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>

        <!-- ★★★ 追加点: ゲーム開始用のオーバーレイ ★★★ -->
        <div id="start-overlay" class="overlay">
            <h2 class="text-3xl font-bold mb-4">タップして開始</h2>
            <p>パドルをドラッグして操作</p>
        </div>

        <!-- ゲームオーバー/クリア表示用のモーダル -->
        <div id="modal" class="hidden overlay">
             <div class="bg-white text-gray-800 p-8 rounded-lg text-center shadow-xl mx-4">
                <h2 id="modal-title" class="text-3xl font-bold mb-4"></h2>
                <p id="modal-score" class="text-xl mb-6"></p>
                <button id="restart-button" class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 transition">
                    もう一度遊ぶ
                </button>
            </div>
        </div>
    </div>
    <div class="controls">
        PC: マウスで操作 / Touch: 画面をドラッグ
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const livesElement = document.getElementById('lives');

    const startOverlay = document.getElementById('start-overlay');
    const modal = document.getElementById('modal');
    const modalTitle = document.getElementById('modal-title');
    const modalScore = document.getElementById('modal-score');
    const restartButton = document.getElementById('restart-button');

    // --- ゲームの状態管理 ---
    let score, lives;
    let gamePaused = true;
    let animationFrameId;

    // --- ゲーム要素のサイズや位置 ---
    let ballRadius, x, y, dx, dy;
    let paddleHeight, paddleWidth, paddleX;
    let brickRowCount, brickColumnCount, brickWidth, brickHeight, brickPadding, brickOffsetTop, brickOffsetLeft;
    let bricks = [];

    function resetGameElements() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;

        ballRadius = canvas.width * 0.02;
        paddleWidth = canvas.width * 0.25;
        paddleHeight = canvas.height * 0.03;
        brickRowCount = 5;
        brickColumnCount = 7;
        brickPadding = canvas.width * 0.015;
        const totalPaddingWidth = brickPadding * (brickColumnCount + 1);
        brickWidth = (canvas.width - totalPaddingWidth) / brickColumnCount;
        brickHeight = canvas.height * 0.06;
        brickOffsetTop = canvas.height * 0.1;
        brickOffsetLeft = brickPadding;

        x = canvas.width / 2;
        y = canvas.height - paddleHeight - ballRadius - 10;
        paddleX = (canvas.width - paddleWidth) / 2;

        const speed = canvas.width * 0.006;
        dx = speed;
        dy = -speed;
    }

    function setupBricks() {
        bricks = [];
        for (let c = 0; c < brickColumnCount; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: 1 };
            }
        }
    }

    // --- イベントリスナー ---
    function handlePointerMove(e) {
        if (gamePaused) return;
        const relativeX = (e.clientX || e.touches[0].clientX) - canvas.getBoundingClientRect().left;
        if (relativeX > paddleWidth / 2 && relativeX < canvas.width - paddleWidth / 2) {
            paddleX = relativeX - paddleWidth / 2;
        }
        e.preventDefault();
    }

    canvas.addEventListener("touchmove", handlePointerMove, false);
    canvas.addEventListener("mousemove", handlePointerMove, false);

    restartButton.addEventListener('click', () => {
        modal.classList.add('hidden');
        init();
    });

    startOverlay.addEventListener('click', () => {
        startOverlay.classList.add('hidden');
        init();
    });

    // --- 描画関数 ---
    function drawElements() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBricks();
        drawBall();
        drawPaddle();
    }

    function drawBall() {
        ctx.beginPath();
        ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
        ctx.fillStyle = "#34d399";
        ctx.fill();
        ctx.closePath();
    }

    function drawPaddle() {
        ctx.beginPath();
        ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
        ctx.fillStyle = "#60a5fa";
        ctx.fill();
        ctx.closePath();
    }

    function drawBricks() {
        const colors = ["#f87171", "#fbbf24", "#4ade80", "#60a5fa", "#a78bfa"];
        for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
                if (bricks[c][r].status == 1) {
                    const brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                    const brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                    bricks[c][r].x = brickX;
                    bricks[c][r].y = brickY;
                    ctx.beginPath();
                    ctx.rect(brickX, brickY, brickWidth, brickHeight);
                    ctx.fillStyle = colors[r % colors.length];
                    ctx.fill();
                    ctx.closePath();
                }
            }
        }
    }

    function collisionDetection() {
        for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
                const b = bricks[c][r];
                if (b.status == 1 && x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                    dy = -dy;
                    b.status = 0;
                    score++;
                    scoreElement.textContent = score;
                    if (score == brickRowCount * brickColumnCount) {
                        showModal("ゲームクリア！", `最終スコア: ${score}`);
                    }
                }
            }
        }
    }

    function showModal(title, scoreText) {
        gamePaused = true;
        modalTitle.textContent = title;
        modalScore.textContent = scoreText;
        modal.classList.remove('hidden');
        cancelAnimationFrame(animationFrameId);
    }

    function update() {
        if (gamePaused) return;

        // 壁との衝突判定
        if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;

        // 天井との衝突判定
        if (y + dy < ballRadius) dy = -dy;
        // 床との衝突判定（ゲームオーバー処理）
        else if (y + dy > canvas.height - ballRadius) {
            // パドルとの衝突判定
            if (x > paddleX && x < paddleX + paddleWidth) {
                dy = -dy;
            } else {
                lives--;
                livesElement.textContent = lives;
                if (!lives) {
                    showModal("ゲームオーバー", `最終スコア: ${score}`);
                    return; // ゲームループを抜ける
                } else {
                    // ライフを失った後のリセット
                    x = canvas.width / 2;
                    y = canvas.height - paddleHeight - ballRadius - 10;
                    paddleX = (canvas.width - paddleWidth) / 2;
                }
            }
        }

        x += dx;
        y += dy;
    }

    // メインのゲームループ
    function gameLoop() {
        update(); // ボールの位置などを更新
        drawElements(); // 更新された位置で描画
        collisionDetection(); // 衝突判定

        if (!gamePaused) {
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    }

    // ゲームの初期化と開始
    function init() {
        resetGameElements();
        setupBricks();
        score = 0;
        lives = 3;
        scoreElement.textContent = score;
        livesElement.textContent = lives;
        gamePaused = false;

        cancelAnimationFrame(animationFrameId); // 古いループをクリア
        gameLoop();
    }

    // ★★★ 修正点: ページ読み込み完了後に初期描画だけを行う ★★★
    window.addEventListener('load', () => {
        resetGameElements();
        setupBricks();
        drawElements(); // 静的な初期画面を描画

        // ウィンドウリサイズ時の処理
        let resizeTimer;
        window.addEventListener('resize', () => {
            gamePaused = true;
            cancelAnimationFrame(animationFrameId);
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                resetGameElements();
                setupBricks();
                drawElements();
                startOverlay.classList.remove('hidden'); // 開始画面に戻す
                modal.classList.add('hidden');
            }, 250);
        }, false);
    });

</script>
</body>
</html>
